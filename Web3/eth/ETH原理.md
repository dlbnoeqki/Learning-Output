## ETH账户
基于账户的模式，记录`balance`
天然防范`double spending attack`
加入 `nonce`「交易次数」字段防范`replay attack`
以太坊状态可以分为：
- 外部账户
- 合约账户
	- 不能主动发起交易
	- 合约可以调用另一个合约
基于账户的模式，加强了隐私性，账户地址不变利于智能合约。

## ETH状态树
以太坊的状态树是维护整个网络状态的核心数据结构。它的作用是跟踪每个账户的余额、存储数据和智能合约代码。以太坊的状态树是一个`MPT`(Merkle Patricia Trie)，它是一种特殊的Hash树。
![[eth-status-tree-detail.png]]
状态树的作用：
- 数据完整性和安全性
- 高效的状态存储和检索
- 快速校验和同步
- 智能合约指向和状态更新
![[eth-status-tree.png]]
以太坊状态树由三个部分组成：
- 全局状态树
	- 以太坊的主要状态树，根节点称为“状态根”。包含了所有账户的的状态，每个账户状态由其Hash值索引。
- 账户树
	- 每个账户在全局状态树中有一个对应的节点，这些节点包含账户的基本信息：
		- 余额
		- 交易计数器
		- 合约代码hash
		- 存储根（存储合约的变量）
	- 账户分为：
		- 外部账户，私钥控制
		- 合约账户，包含智能合约代码
- 存储树
	- 对于每个合约账户，其状态树节点中的存储根指向一个存储树。存储树保存智能合约的所有存储变量和数据
	
以太坊系统中每个全节点都需要维护状态树，但是每笔交易可能只会修改状态树中少数账户的状态；另外以太坊引入了智能合约的支持，必然需要回滚账户的状态，合约账户的状态回滚相对比较复杂，所以需要保留账户的历史状态，而不是每次在原有的账户节点中进行修改。
![[eth-account-staus-history.png]]
### 以太坊区块结构
```json
{
// 块头
  "blockHeader": {
    "parentHash": "0x...", // 上一个区块的哈希值
    "ommerHash": "0x...",// 包含叔块（即不在主链上的有效块）的哈希值
    "beneficiary": "0x...", // 矿工的奖励接收地址
    "stateRoot": "0x...", // 当前区块中发布时状态树根哈希值
    "transactionsRoot": "0x...", // 当前区块中所有交易的Merkle树根哈希值
    "receiptsRoot": "0x...", // 当前区块中所有交易收据的Merkle树根哈希值
    "logsBloom": "0x...", // 当前区块中所有交易日志的Bloom过滤器，用于快速查找
    "difficulty": "0x...", // 当前区块的难度
    "number": 1234567, // 区块高度（区块在区块链中的编号）
    "gasLimit": 8000000, // 当前区块的最大Gas限制
    "gasUsed": 5000000, // 当前区块中已使用的Gas总量
    "timestamp": 1620000000, // 区块生成的时间戳
    "extraData": "0x...", // 额外数据字段，可以包含任意数据
    "mixHash": "0x...", // 用于证明工作量证明的哈希值
    "nonce": "0x..." // 用于解决工作量证明算法的随机数
  },
  // 每个区块包含一组交易，这些交易存储在一个列表中：
  "transactions": [
    {
      "nonce": 0, // 发送者发送的交易数量
      "gasPrice": "0x...", // 发送者愿意为每单位Gas支付的价格
      "gasLimit": 21000, // 发送者愿意为交易支付的最大Gas数量
      "to": "0x...", // 交易接收者地址（如果是合约创建交易，则为空）
      "value": "0x...", // 交易发送的以太币数量
      "data": "0x...", // 交易的数据字段，用于合约调用或合约创建
      "v": "0x...", // 用于交易签名的值
      "r": "0x...", // 用于交易签名的值
      "s": "0x..." // 用于交易签名的值
    },
    {
      "nonce": 1,
      "gasPrice": "0x...",
      "gasLimit": 80000,
      "to": "0x...",
      "value": "0x...",
      "data": "0x...",
      "v": "0x...",
      "r": "0x...",
      "s": "0x..."
    }
  ],
  // 叔块的列表，每个叔块都有一个与普通区块相似的结构
  // “未被主链采用但仍然有效的区块”
  "ommers": [
    {
      "blockHeader": {
        "parentHash": "0x...",
        "ommerHash": "0x...",
        "beneficiary": "0x...",
        "stateRoot": "0x...",
        "transactionsRoot": "0x...",
        "receiptsRoot": "0x...",
        "logsBloom": "0x...",
        "difficulty": "0x...",
        "number": 1234566,
        "gasLimit": 8000000,
        "gasUsed": 3000000,
        "timestamp": 1619999990,
        "extraData": "0x...",
        "mixHash": "0x...",
        "nonce": "0x..."
      }
    }
  ]
}
```
## ETH交易树与收据树
在以太坊中，交易和树收据树是区块结构中重要的两个组成部分。它们也都是MPT的实例，用于存储和验证区块中的交易和交易收据。
![[eth-full-node-stores.png]]
### 交易树
存储区块中所有的交易。每笔交易都有一个唯一的索引，称为“交易索引”。用于标识该交易在区块中的位置。
#### 结构
- 叶子节点：每个叶子节点存储单个交易的hash值。
- 中间节点：中间节点存储其子节点hash值的组合，通过hash函数递归的计算。
- 根节点：根节点hash值代表整个收据树的的hash值，存储在区块头中【transactionsRoot】。
#### 作用
- 数据完整性和验证：通过MPT结构，任何单个交易的变化都会导致根Hash值的变化。
- 高效检索和验证：验证某个交易是否包含在区块中，只需要计算从该区块中根节点的路径上的hash值，提供了一种高效的验证方式。
- 区块同步：节点在同步区块时，可以通过交易树的根hash值快速验证区块中所有交易的正确性。

### 收据树
存储区块中每个交易的收据。每个交易收据包括交易执行后的状态信息、日志和消耗的gas等等。
#### 结构
- 叶子节点：每个叶子节点存储存储单个交易收据的hash值
- 中间节点：中间节点存储其子节点hash值的组合，通过hash函数递归的计算。
- 根节点：根节点hash值代表整个收据树的的hash值，存储在区块头中【receiptsRoot】。
#### 作用
- 数据完整性和验证：收据树确保每个交易的收据的完整性和不可篡改性。任何单个收据的变化都会影响到根hash值。
- 高效检索和验证：验证某个交易收据是否包含在区块中，只需要计算从该收据到根节点的路径上的hash值。
- 智能合约调试与分析：交易收据提供了执行交易后的详细信息：
	- status：交易的执行状态（成功或失败）
	- cumulativeGasUsed：区块中从第一个交易到当前交易累计消耗的gas
	- logsBloom：用于快速过滤和查找交易日志的Bloom Filter
	- logs：交易执行过程中生成的日志数组
	便于开发者调试和分析智能合约行为。
### 复杂查询
以太坊中支持一些比较复杂的查询，例如查询某个区块中调用了某个合约的交易。
#### Bloom Filter
Bloom Filter的数据结构是一个长度为n的位数组。桶的位置由长度为n的位数组的索引(0～n)表示。当Bloom Filter初始化(一个空的Bloom Filter)时，Bloom Filter中的所有位都被设置为0。Bloom Filter丢弃元素本身的值，但仅存储一组由对元素执行hash函数标识的位。Bloom Filter有以下性质：
- O(1)的复杂读
- 内存占用小
- 插入、查询可以并行
- 能够快速查询某个元素是否存在于集合中
![[bloom filter.png]]
因为存在hash碰撞【图中使用一组hash函数对元素求hash，减小hash碰撞的可能】的原因，同一个bucket可能被多个不同的元素标记，这种情况下，当验证某个元素是否存在时，`可能产生误报，但不会漏报`。但如果某个bucket没有被任何元素标记，那么验证一个不存在的元素是否存在时，它的结果是准确的。
显然，Bloom Filter的局限性是它`不支持删除`。
#### Bloom Filter在以太坊中的应用
每个交易生成的收据中会产生一个Bloom Filter，每个区块会把当前区块中的 所有交易产生的收据里的Bloom Filter做并集结果记录在区块头。
需要查询时，先从区块头的Bloom Filter过滤，如果存在，再去具体的交易对应的收据树中的Bloom Filter进行过滤，得出结果。
通过Bloom Filter的数据结构可以快速过滤掉大量无关的区块。
### 基于交易驱动的状态机
以太坊的运行过程可以看作是一个`基于交易驱动的状态机`。类似BTC的UTXO一样。
![[eth-status-machine.png]]
`状态转移`必须`确定性`的：对于给定的当前状态和一组给定的交易，能够确定性转移到下一个状态。因为对于同一个区块，所有的全节点都必须执行相同的状态转移。

### 与状态树的区别
交易树与收据树只保存了当前区块中的交易对应的信息。而状态树中维护了全球的以太坊账户状态。
状态树不能像交易树和收据树一样设计成只保存当前区块中交易涉及到的账户状态：因为极有可能会接收到某笔交易中涉及到的账户是`第一次`进行交易，遇到这种账户就很难确定账户的状态，需要从当前区块向前追溯查找该账户的状态，最坏情况可能需要追溯到`创世纪块`。
## GHOST协议
以太坊的GHOST协议（Greedy Heaviest Observed Subtree）是用于改进区块链共识机制的协议。它的主要目的是通过更好地处理区块链中的叔块（uncle blocks），来提高区块链的安全性和网络吞吐量。
### 背景
在传统的区块链共识机制中（例如比特币的最长合法链规则），矿工总是选择最长的合法区块链作为新的区块添加到链上的基础。然而，这种机制存在一些缺点：
- 孤块率高：当多个矿工几乎同时找到新区块时，只有一个区块能成为主链的一部分，其余的会成为孤块或叔块，这会`浪费大量计算资源`。
- 网络安全性：由于孤块不参与共识，这会导致有效算力的浪费，降低整体网络的安全性。
区别于BTC，以太坊大幅度降低了出块时间，这就会导致区块链中会产生频繁的分叉，给去中心化系统的共识机制带来挑战。
BTC不受影响是因为，对于网络传输来说，它的出块时间足够长，而且BTC区块链中是只认可`最长合法链`，节点竞争造成的分叉只会是临时的。
### 概念
GHOST协议的核心思想是选择包含更多工作量（即更多有效区块，包括叔块）的子链，而不是仅选择最长的链。
### 工作机制
以太坊使用了一种称为“修剪的GHOST”协议（Modified GHOST Protocol）。以下是具体应用：
1. 叔块的引用：
	- 以太坊引入了叔块的概念，允许`每个新区块最多引用两个叔块`。被引用的叔块可以`来自主链的前七层以内`，且是分叉后的第一个区块，避免降低分叉攻击的成本。
2. 叔块的奖励：
	- 被引用的叔块和引用它们的区块`都可以获得奖励`。叔块的奖励为其区块奖励的一部分（具体比例根据其与主链区块的高度差异决定）。
3. 区块奖励机制
	- 矿工不仅获得新区块的奖励，还能从引用的叔块中获得额外的奖励。这种机制鼓励矿工及时广播区块，减少因网络延迟而产生的孤块。
![[eth-uncle-block.png]]
## 挖矿算法
为了应对专用矿机【芯片主频极高】对普通机器的性能冲击。需要设计一种挖矿算法，增加运算过程中对内存访问的需求。以太坊最初采用的是一种被称为`Ethash`的挖矿算法。这是一种基于工作量证明【POW】的算法，设计上考虑了ASIC对网络的影响，并确保挖矿的中心化。
### Ethash挖矿算法的工作原理
Ethash是一个内存硬性的算法，这意味着它需要大量的内存来进行计算，从而使ASIC矿机难以在成本和效率上取得优势。Ethash算法包括以下几个关键步骤：
1. 初始化数据集（DAG）
	1. Ethash使用了一个名为DAG【Directed Acyclic Graph，有向无环图】的数据结构，该数据集大小随着时间推移而增加。
	2. 每隔30000个区块（约5天），DAG会重新生成一次。这段时间称为一个epoch。
2. 种子计算
	1. 每个epoch开始时，矿工会生成一个种子值seed，种子值是由区块链的所有先前区块通过递归hash计算得到。
3. 缓存生成
	1. 根据种子值生成一个大小为16MB的缓存，这个缓存用于生成DAG。
	2. cache的初始大小为16MB，每个epoch后重新生成时增大初始大小的1/128（128k）。
```python
def mkcache(cache_size, seed):
	o = [hahs(seed)]
	for i in range(1,cache_size):
		# 每个元素的生成与上一个元素有关
		o.append(hash(o[-1]))
	return o
```
4. DAG生成
	1. 使用缓存生成DAG。DAG的大小约为缓存的64倍，最初大约为1GB，并随着时间增加。目前DAG大小已超过4GB。
```python
def calc_dataset_item(cache, i):
	cache_size = cache.size
	mix = hash(cache[i % cache_size] ^ i)
	for j in range(256):
		# 根据当前的mix值求得下一个要访问的cache元素的下标
		cache_index = get_int_from_item(mix)
		# 用这个cache元素和mix求得新mix值
		mix = make_item(mix, cache[cache_index % cache_size])
	# 返回mix的hash值，得到第i个dataset中的元素
	return hash(mix)
```
1. 挖矿过程
	1. 矿工使用DAG和区块头信息（包括区块的nonce值）计算一系列hash值。
	2. 挖矿的目标是找到一个nonce，使得计算出的hash值小于网络的目标难度值。
```python
# 矿工挖矿函数，不断调整nonce尝试此函数，直到找到符合要求的nonce  
def hashimoto_full(header, nonce, full_size, dataset):  
    mix = hash(header, nonce)  
    for i in range(64):  
        dataset_index = get_int_from_item(mix) % full_size  
        mix = make_item(mix, dataset[dataset_index])  
        mix = make_item(mix, dataset[dataset_index + 1])  
    return hash(mix)  
  
# 轻节点验证矿工发布的区块函数  
def hashimoto_light(header, nonce, full_size, cache):  
    mix = hash(header, nonce)  
    for i in range(64):  
        dataset_index = get_int_from_item(mix) % full_size  
        # 轻节点没有保存DAG，需要每次计算DAG中特定位置的值  
        mix = make_item(mix, calc_data_item(cache, dataset_index))  
        mix = make_item(mix, calc_dataset_item(cache, dataset_index + 1))  
    return hash(mix)
```
## 难度调整

## 权益证明

## 智能合约
