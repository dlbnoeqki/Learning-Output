区块链是一个`去中心化的账本`，比特币采用的是`基于交易的账本模式`。
比特币系统中只记录了交易信息，没有显示记录每个账户的余额，只能通过交易信息推算账户的余额。
## BTC密码学
### Hash函数 
- hash碰撞，x !=y,H(x) = H(y)
- hiding，hash函数的计算过程是单向的，不可逆的 x ->H(x)
- 生成digest，防篡改
- 无法人为制造hash碰撞
- 输入空间要足够大，取值保证均匀
### 签名
- 公钥【加密】+私钥【解密】，非对称加密：使用接收方的公私钥，私钥不需要传输，留在本地供自己解密
- 公钥即账户账号，私钥即账户密码
- 发布交易，使用自己的私钥对交易签名。其他人需要验证的，使用我的公钥进行验证签名
- 256位的hash值，如果想要产生一个相同的公私钥对，理论上可行，但实际上不行，概率极低，输入空间很大，且产生公私钥对需要有一个好的随机源

## BTC数据结构
### Hash指针
hash指针保存区块的内存地址与区块的hash值，可以根据hash指针找到区块的位置，也能检测出区块是否被篡改。
### 区块链
区块链即由区块组成的链表。区别与普通的链表，有以下区别：
1. 使用hash指针替代普通的指针
2. hash值是计算【指向区块】+【其指向上一区块的hash指针的hash值】一起计算
### 默克尔树
区别于二叉树，使用hash指针替代普通的指针
除了最底层为数据块【记录交易】，其他层自底向上取Hash，直到求到树顶的Root Hash
作用：证明交易确实发生
![[merkle_proof.png]]
证明一个交易存在于默克尔树中，时间复杂度为O(log(n))
在不排序的情况下，无法高效验证某笔交易是否存在于默克尔树中。
篡改某笔交易后，会改变克尔树Root Hash：
![[调整coinbase域.png]]
### 区块
#### Header
不记录交易的具体内容，记录默克尔树的Root Hash
- 比特币使用的协议
- 指向前一个区块的Hash指针（只算Header的Hash）
- 默克尔树的根Hash
- target，挖矿难度阈值
- nonce，随机数
#### Body
记录默克尔树，即交易的具体的内容
- 交易列表
### UTXO
比特币的全节点需要维护UTXO【未花费的交易输出】，一笔交易可能会有多个输出。
UTXO中的每个元素要给出产生这个交易的Hash值以及它在这个交易里是第几个输出。利用这两个信息就可以定位到UTXO中的输出。
作用：校验新产生的交易是否合法，交易的币来源需要在UTXO中，快速检测双花攻击。
每个交易会消耗一些输出，同时会产生一些新的输出。
如果某个账户收到转账交易之后，始终都不花，那么这个输出就会一直永久保存在UTXO里。
每个交易可以有多个输入，也可以有多个输出，所有的输入的金额要等于所有输出的金额。
![[UTXO-MODEL.png]]

## BTC的共识协议
数字货币面临的第一个问题，就是“双花”攻击，也就是一笔钱被花两次。如果在中心化的系统中比较容易解决，只要数据库中记录每笔钱的目前拥有者即可。
在比特币系统中，一笔交易需要有输入输出：
![[BTC的交易.jpg]]
- 输入
	- 币的来源【携带当前交易发起人的公钥Hash】
	- 当前交易发起人的公钥
- 输出
	- 收款人公钥的Hash
每一笔交易，所有节点都需要知道交易发起人的公钥，用来验证该笔交易的签名（是否是本人发起的）
BTC系统中的节点分为：
- 全节点，保存区块链的所有信息，验证每一笔交易；参与构造与维护区块链
- 轻节点，只保存区块的信息（大多数节点）
### 投票
把一笔交易写入区块需要比特币系统中的全节点达成某种共识，避免存在恶意节点，保证数据一致性。
使用投票的方式达成共识，决定谁能够获得记账权，可以忘区块中记录交易：
1. 简单投票，得票最多的节点获得记账权，但它存在以下隐患：
	1. 恶意节点不参与投票
	2. 恶意节点持续提交存在虚假交易的区块
	3. 女巫攻击，恶意节点生成大量的公私钥对
2. 算力投票，比拼每个节点每秒能计算的Hash值：
	1. 过程：每个全节点都有权利在自己本地组装合法交易，打包成候选区块，然后尝试各种nonce值，直到找到符合H(header||nonce) <= target的nonce值，就获得记账权，然后把候选区块发布出去
	2. 其他节点接收，验证、接受：他节点接收到该候选区块会先验证区块是否合法，包括nonce值是否符合要求，区块中的每笔交易是否合法，交易的币来源是否正确，交易的签名是否正确等等；如果节点接受了区块，它就会延续该区块向后扩展【本地状态交易，打包区块，尝试nonce值，发布区块】。
### 区块链分叉
但是按照算力投票的方式，区块链中难免会出现分叉：
- 恶意分叉
	- 分叉攻击：通过在区块链中间插入一个区块来回滚某个已经发生的交易
- 正常分叉
	- 多个节点几乎同时获得记账权，默认情况下节点会接受最先接收到的区块进行扩展，此时区块链会出现多个分叉。
所以，比特币的协议中有规定，只认可【最长合法链】。

## BTC 网络
新发布的区块在BTC网络的传播过程是一个去中心化，点对点【peer to peer】的过程。
### 广播区块
- 初始广播：成功挖出新区块的旷工节点会将这个区块广播给其直接连接的邻近节点。
- 传播方式：BTC网络使用Gossip协议来传播新区块；每个节点将新区块信息传递给其邻居节点，邻居节点【验证区块】再将区块传递给它们的邻居节点，这个过程会不断重复，直到传播到整个BTC网络中大部分节点，一旦大多数及诶点接受并添加了新区块，网络中区块链就会更新，新区块成为区块链最新部分，后续的区块将基于这个新区块继续构建。
- 传播延迟：由于网络延迟和节点间连接速度不同，新区块在网路中传播会有一些时间差。通常传播时间在几秒到几十秒之间。
节点本地维护一个交易集合， 接收到冲突的交易需要排除冲突的交易。
### 邻居节点
邻居节点的选择，不是按距离，而是随机的。所以向美国的账户转账和向隔壁邻居转账的速度可能是一样的。
## 挖矿
- 挖矿的本质：
	矿工不断调整铸币交易的coinbase域+nonce，直到找到符合的nonce值。
- 挖矿的设备演进：
	CPU->GPU->ASIC,从通用到专用。
- 矿工从个体到矿池：
	减轻矿工的负担，稳定矿工的收入。但是发动51%算力攻击也变得容易。
### 挖矿的奖励
1. 出块奖励
	1. 一比特殊交易，铸币交易。
	2. 比特币系统中唯一发行货币的方式。
	3. 出块奖励会减半：21万 * 10分钟约等于4年。
3. 交易手续费
	1. 交易手续费的金额取决于交易金额的大小和网络拥堵情况，矿工优先打包手续费多的交易。
	2. 收取交易金额的一部分作为报酬。
### 挖矿难度
H(block header) <= target，target越小，挖矿难度越大，调整挖矿难度，就是调整目标空间在整个输出空间的比例。
BTC系统使用的Hash算法是：SHA-256，产生的Hash值为256位，所以总的输出空间为2的256次方。

挖矿难度 = (挖矿难度为1时target) / target
挖矿难度最小为1，当难度为1时，target是一个很大的数，也就表示输出占目标空间比例非常大。
### 调整挖矿难度
调整挖矿难度是为了维持系统的出块时间保持在10分钟左右，出块时间太短，区块链的分叉会很频繁且过多，不利于系统达成共识。甚至不需要51%算力的攻击也能对系统造成威胁。

比特币系统每隔2016个区块调整挖矿难度，大概14天调整一次。
target = target *（ actual time(2016个区块实际花费的时间) / expected time(2016 * 10，期望时间)）
在实际情况中，上调和下调都有4倍的限制

*如何避免矿工偷取别人的nonce？*
交易列表的Coinbase交易可以避免矿工偷取其他矿工正确的nonce，coinbase交易指向了当前的矿工，如果其他矿工要修改这笔coinbase交易，merkletree的root hash也需要修改，间接导致整个区块的hash变化，偷取的nonce也就不会符合条件。
*交易费如何给到矿工？*
只要total inputs > total output时，矿工就可以把差额当作交易费，在构建区块区块时，矿工在coinbase交易中为自己创建一个输出，包含新区块奖励和交易费
### 挖矿的无记忆性
比特币系统调整区块的target阈值来保证区块的出块时间维持在10分钟左右。
决定矿工能挖到下一个区块的时间是自身的算力占系统总算力的百分比，例如自身占有系统1%的算力，那么系统每产生100个区块就有1个区块是你挖到的，
也就是平均要等1000分钟才能挖到一个区块；将来还要挖多久，跟过去挖了多久无关，平均还是要挖10分钟。过去的进程是无用的。
理解比特币挖矿的算力竞争和无记忆性：
1. 算力竞争
	1. 算力是指矿工能够进行hash运算的速度，算力越强，矿工在单位时间内能够尝试的hash次数越多，找到符合条件的hash值的概率就越大，因此，算力越强的矿工相对来说更容易成功挖到区块并获得奖励
2. 挖矿的无记忆性
	1. 每一次尝试找到符合条件的hash值的过程是独立的。没有记忆之前的尝试。
	2. 每个新hash运算的结果都是随机的，与之前的运算结果无关。
	3. 过去无论尝试了多少次，花了多长时间都不影响未来成功的概率
挖矿的无记忆性是为了避免算力强的矿工有不成比例的优势，保证挖矿的公平。

### 挖矿的意义
比特币挖矿求解puzzle除了比拼算力，没有别的意义。比特币的稀缺性是人为造成的。
但是比特币挖矿的过程对维护比特币系统的运行是至关重要的。越来越多的矿工参与到挖矿，只要大部分算力掌握在正常矿工手里，比特币系统的安全就能得到保证。
恶意节点占有比特币系统大部分算力后可以对系统进行攻击：
1. 伪造交易，把伪造的交易打包进区块发布
	1. 正常节点不会接受，比特币系统最终只认最长合法链，而不仅是最长
2. 回滚交易
	1. 转出去的钱币转回给自己。多等待几个区块，也就是多次确认，一般6次确认，就可以认为前面的交易是不可篡改的。
3. 挖到区块不发布 selfish mining
	1. 挖到区块先不发布，然后自己继续挖，挖到多个之后一并发布出去，可以回滚交易。
	2. 减少竞争，但存在风险
	3. 
### 比特币的总量
因为比特币协议规定了每21万个区块后，矿工得到的出块奖励会减半，所以比特币是有限的。
= 21万区块 * 50个
= 21万区块 * 25个
= 21万区块 * 12.5个
= 21万区块 * 6.125个
= 21万 * 50 *（1+1/2+1/3+1/4+...) = 2100万
## BTC脚本
比特币系统中的脚本语言是一种基于栈的、非图灵完备的编程语言，设计用于执行比特币交易中的条件验证。比特币脚本非常简单且功能有限，以确保其安全性和可预测性。
比特币脚本通常分为两部分：
- 输入脚本
- 输出脚本
当一个交易被验证执行时，这两个脚本会被组合在一起并执行，以验证交易的合法性。
验证交易：当前交易的input scripts 拼上提供币来源的交易的out scripts配对执行
### 交易示例
```json
{
  "txid": "7a5a4e327ad0ae92637e9c9047a5a88b2bd717a134888dd5730a4c271d8dd411",
  "size": 225,
  "version": 1,
  "locktime": 0,
  "fee": 3569,
  "inputs": [
    {
      "coinbase": false,
      "txid": "7b84a71834c1f0a3dc1a3529ab5d1d5d490d5de6242fa2e93cd882d1e5b76606",
      "output": 1,
      "sigscript": "",
      "sequence": 4294967295,
      "pkscript": "0014adf805b7bd015fbc2640195019fbeaeb0c36cdcb",
      "value": 205078,
      "address": "bc1q4huqtdaaq90mcfjqr9gpn7l2avxrdnwt3ttwg7",
      "witness": [
        "304402202cf3b6eb7fae6abf75d587d7bfe9bdb9ee6d9e32b6fde9dbe0dfed422bb25b610220260e9f36869cf93fbfa3322be48b2de7d9bb1f8c819204e4360164c59a3c9ead01",
        "039b5106d5c6b5546cc29ae93f865441f4882ed8b4bf7e855ae2a7c171be80b8fd"
      ]
    }
  ],
  "outputs": [
    {
      "address": "176yAbtUFzggejHtFz7EUodUHZLPsX5hVW",
      "pkscript": "76a91442f1b819f3d73fa03e1bc264f4d13cbaf207f3c488ac",
      "value": 29560,
      "spent": false,
      "spender": null
    },
    {
      "address": "bc1qd5gust2lp9fwyjpvufqhkckl9nfrywpkqel5sj",
      "pkscript": "00146d11c82d5f0952e2482ce2417b62df2cd2323836",
      "value": 171949,
      "spent": false,
      "spender": null
    }
  ],
  "block": {
    "mempool": 1717240460
  },
  "deleted": false,
  "time": 1717240460,
  "rbf": false,
  "weight": 573
}
```
### 不同类型的脚本
比特币脚本有多种类型，用于实现不同的支付和条件验证方式。发起交易指定
#### P2SH(Pay-to-Script-Hash)
P2SH允许复杂的条件支付，通过将脚本的hash存储在输出中。在解锁时，提供整个脚本和满足条件的数据。
#### P2PK(Pay-to-PubKey)
P2PK直接支付给一个公钥
#### P2WPKH(Pay-to-Witness-PubKey-Hash)
P2WPKH是隔离见证（SegWit）的一部分，它减少了交易大小和提供了安全性。
#### P2WSH(Pay-to-Witness-Script-Hash)
P2WSH是隔离见证版本的P2SH，用于更复杂的条件支付。
#### 多重签名(MultiSig)
多重签名要求多个签名才能验证成功才能花费资金，常用于增加安全性。
1.  生成公钥：Alice、Bob和Charlie各自生成一对公私钥
2. 创建多签名地址：使用3个公钥生成一个2-of-3多签名地址
3. 接收比特币：将比特币发送到这个多签名地址
4. 交易比特币：3个人中其中2个用自己的私钥对交易签名即可
#### OP_RETURN
OP_RETURN允许在区块链上存储不可花费的数据，常用于嵌入小额信息
如果花费，OP_RETURN存在币的来源交易脚本的输出，始终返回错误，交易验证会失败，所以永远无法花费出去。

## BTC分叉
在比特币系统中，硬分叉和软分叉是两种不同的协议升级方式。它们的主要区别在于对网络的兼容性和区块链的分裂方式
### 硬分叉
	定义：硬分叉是对比特币协议的一个不向后兼容的升级。这意味着新规则和旧规则不兼容，节点必须升级到新规则才能继续参与验证新区块。
	网络影响：在硬分叉后，如果部分节点选择不升级，那么网络将分裂成两个独立的区块链，每个链都有自己独立的历史记录和未来区块。这就会导致产生两个独立的加密货币。
	升级过程：需要节点明确的决定是否升级到新规则。未升级的节点将不能参与新链的区块验证。
	应用场景：硬分叉通常用于需要对协议进行重大更改的场景，例如增加去亏啊大小、改变共识机制等等。
	
### 软分叉
	定义：软分叉是对比特币协议的一种向后兼容的升级。这意味着新规则与旧规则兼容，未升级的节点仍然可以验证和接收新规则生成的区块，但它们可能无法创建新的区块。
	网路影响：软分叉通常不会导致区块链的分裂。所以节点，即使没有升级到新规则的节点，也可以继续在同一个链上进行操作。
	升级过程：软分叉可以通过共识逐步实现，只需要大多数节点支持新规则即可生效。旧节点仍然可以识别并接受新生成的区块，但不能生成不符合新规则的区块。
	应用场景：软分叉通常用于较小的升级或改进，例如添加新的交易类型、优化某些操作。

### 区别总结
- 兼容性：硬分叉是非兼容的，软分叉是兼容的。
- 网络分裂：硬分叉可能导致区块链分裂，软分叉通常不会。
- 升级需求：硬分叉需要所有节点明确升级，软分叉可以逐步通过共识实现。
- 应用场景：硬分叉用于重大协议更改，软分叉用于较小改进或功能添加。

零知识证明
同态隐藏
盲签方法
零币和零钞

**不要被学术界的思维限制了头脑，不要被程序员的思维限制了想象力。**

比特币的非对称加密体系：私钥时可以推导出公钥的，反之则不行。比特币系统没有直接把公钥暴露，而是对公钥进行hash。